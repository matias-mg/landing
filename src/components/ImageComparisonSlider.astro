---
import BlurImage from "./BlurImage.astro";

const {
  leftImage,
  rightImage,
  leftImageSrc = "",
  rightImageSrc = "",
  loading = "lazy",
  classStyles = "",
  leftImageAlt = "",
  rightImageAlt = "",
} = Astro.props;
---

<div class="image-comparison">
  <BlurImage
    img={leftImage}
    src={leftImageSrc}
    alt={leftImageAlt}
    loading={loading}
    classStyles={`image image-left ${classStyles}`}
  />
  <BlurImage
    img={rightImage}
    src={rightImageSrc}
    alt={rightImageAlt}
    loading={loading}
    classStyles={`image image-right ${classStyles}`}
  />
  <div class="slider-handle z-30">
    <div class="slider-line bg-blue-300"></div>
    <div class="slider-arrows text-blue-300">
      <svg
        class="slider-arrow left-arrow"
        viewBox="0 0 24 24"
        width="44"
        height="44"
      >
        <path
          d="M15 18l-6-6 6-6"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg>
      <svg
        class="slider-arrow right-arrow"
        viewBox="0 0 24 24"
        width="44"
        height="44"
      >
        <path
          d="M9 18l6-6-6-6"
          fill="none"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg>
    </div>
  </div>
</div>

<style>
  .image-comparison {
    position: relative;
    width: 100%;
    height: 400px; /* Adjust as needed */
    overflow: hidden;
    user-select: none;
  }

  .image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    pointer-events: none;
  }

  .image-right {
    clip-path: inset(0 0 0 50%);
  }

  .slider-handle {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%;
    width: 80px;
    transform: translateX(-50%);
    cursor: ew-resize;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: bounce 4s infinite;
  }

  @keyframes bounce {
    0%, 100% {
      transform: translateX(calc(-50% - 10px));
    }
    50% {
      transform: translateX(calc(-50% + 10px));
    }
  }

  .slider-line {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 2px;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
  }

  .slider-arrows {
    position: absolute;
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 0 0px;
  }

  .slider-arrow {
    width: 44px;
    height: 44px;
    filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.5));
  }

  /* Prevent text selection */
  .slider-handle,
  .slider-arrow {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  .image-comparison:hover .slider-handle {
    animation: none;
  }
</style>

<script>
  const container = document.querySelector(".image-comparison") as HTMLElement;
  const handle = document.querySelector(".slider-handle") as HTMLElement;
  const rightImage = document.querySelector(".image-right") as HTMLElement;

  let isDragging = false;
  let animationRemoved = false;
  let lastPosition = 50;

  const getPercentage = (pixelValue) => {
    return (pixelValue / container.offsetWidth) * 100;
  };

  const updateSliderPosition = (x) => {
    const percentage = getPercentage(x);
    handle.style.left = `${percentage}%`;
    handle.style.transform = 'translateX(-50%)';
    rightImage.style.clipPath = `inset(0 0 0 ${percentage}%)`;
    lastPosition = percentage;
  };

  const handleMouseDown = (e) => {
    isDragging = true;
    e.preventDefault();
  };

  const handleMouseUp = () => {
    isDragging = false;
  };

  const handleMouseMove = (e) => {
    if (!isDragging) return;
    const rect = container.getBoundingClientRect();
    const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
    updateSliderPosition(x);
    e.preventDefault();
  };

  const removeAnimation = () => {
    if (!animationRemoved) {
      handle.style.animation = 'none';
      handle.style.left = `${lastPosition}%`;
      handle.style.transform = 'translateX(-50%)';
      rightImage.style.clipPath = `inset(0 0 0 ${lastPosition}%)`;
      animationRemoved = true;
    }
  };

  const updateClipPath = () => {
    if (!animationRemoved) {
      const rect = container.getBoundingClientRect();
      const handleRect = handle.getBoundingClientRect();
      const percentage = ((handleRect.left + handleRect.width / 2) - rect.left) / rect.width * 100;
      rightImage.style.clipPath = `inset(0 0 0 ${percentage}%)`;
      lastPosition = percentage;
    }
  };

  handle.addEventListener("mousedown", handleMouseDown);
  document.addEventListener("mouseup", handleMouseUp);
  document.addEventListener("mousemove", handleMouseMove);
  container.addEventListener("mouseover", removeAnimation);

  // Touch events for mobile support
  handle.addEventListener("touchstart", (e) => {
    isDragging = true;
    e.preventDefault();
  });

  document.addEventListener("touchend", handleMouseUp);
  document.addEventListener("touchmove", (e) => {
    if (!isDragging) return;
    const touch = e.touches[0];
    const rect = container.getBoundingClientRect();
    const x = Math.max(0, Math.min(touch.clientX - rect.left, rect.width));
    updateSliderPosition(x);
    e.preventDefault();
  });

  container.addEventListener("touchstart", removeAnimation);

  // Update clip path during animation
  function animationFrame() {
    if (!animationRemoved) {
      updateClipPath();
    }
    requestAnimationFrame(animationFrame);
  }
  animationFrame();
</script>